class Solution 
{
public:
    int minOperations(const vector<int>& nums) 
    {
        const int LENGTH = nums.size();
        int operations = 0;

        for (int i = 1; i < LENGTH; ++i) 
        {
            if (nums[i] != nums[i - 1]) 
            {
                ++operations;
            }
        }

        return operations;
    }
};

// https://leetcode.com/problems/minimum-total-operations/description/

/*

물론입니다. 아래는 해당 LeetCode 문제의 한국어 번역입니다:

---

**3353. 최소 총 연산 횟수**  
난이도: 쉬움

---

정수 배열 `nums`가 주어졌을 때, 이 배열에 대해 임의의 횟수만큼 연산을 수행할 수 있습니다.

각 연산에서는 다음을 수행할 수 있습니다:

1. 배열의 **접두 부분 배열(prefix)**을 선택합니다.
2. 정수 `k`(음수가 될 수도 있음)를 선택하여, 선택된 접두 부분 배열의 각 요소에 `k`를 더합니다.

배열의 접두 부분 배열(prefix)이란 배열의 시작부터 특정 지점까지의 하위 배열을 의미합니다.

배열의 모든 요소를 동일하게 만들기 위해 필요한 **최소 연산 횟수**를 반환하세요.

---

### 예제 1:

입력: 
```
nums = [1, 4, 2]
```
출력: 
```
2
```
설명:

- **연산 1**: 길이가 `2`인 접두 부분 배열 `[1, 4]`를 선택하고, 각 요소에 `-2`를 더합니다. 배열은 `[-1, 2, 2]`가 됩니다.
- **연산 2**: 길이가 `1`인 접두 부분 배열 `[-1]`을 선택하고, 각 요소에 `3`을 더합니다. 배열은 `[2, 2, 2]`가 됩니다.
- 따라서 필요한 최소 연산 횟수는 `2`입니다.

### 예제 2:

입력: 
```
nums = [10, 10, 10]
```
출력: 
```
0
```
설명:

- 모든 요소가 이미 동일하므로, 연산이 필요하지 않습니다.

---

### 제약 사항:

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

이 문제는 배열의 요소들을 모두 동일하게 만들기 위해 필요한 **최소한의 연산 횟수**를 구하는 문제입니다. 각 연산은 배열의 일부를 선택해 특정 값을 더하거나 뺌으로써 이루어집니다.
*/
