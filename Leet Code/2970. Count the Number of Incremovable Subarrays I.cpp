class Solution {
public:
    int incremovableSubarrayCount(vector<int>& nums) 
    {
        const size_t LEN = nums.size();
        int total_subarr = 0;
        int count = 0;

        for (size_t i = 0; i < LEN; ++i) {
            for (size_t j = i; j < LEN; ++j) {
                bool is_inc_subarr = true;
                int previous = -1;
                int start = i;
                int end = j;
                for (size_t k = 0; k < LEN; ++k) {
                    if (!(start <= k && k <= end)) { //  start <= k <= end 사이를 제외한 나머지 원소들이 증가를 추적, 증가하면 증가하는 부분배열로 인정
                        if (previous >= nums[k]) is_inc_subarr = false;  // Check if the current element is greater than the last one
                        previous = nums[k]; // Update the last element
                    }
                }
                count += (int)is_inc_subarr;
            }
        }

        return count;
    }
};

/*

문제 번역
nums에서 부분 배열을 제거하면 nums가 엄격히 증가하는 경우, 해당 부분 배열을 이동할 수 없는 부분 배열이라고 합니다. 
예를 들어, [5, 3, 4, 6, 7]의 부분 배열 [3, 4]는 이를 제거하면 배열이 [5, 6, 7]로 변경되어 엄격히 증가하므로 이동할 수 없는 부분 배열입니다.

nums의 이동할 수 없는 부분 배열의 총 개수를 반환하세요.

비어있는 배열은 엄격히 증가하는 것으로 간주합니다.

부분 배열은 배열 내의 연속된 비어있지 않은 요소들의 시퀀스입니다.



예제 1:
입력: nums = [1,2,3,4]
출력: 10
설명: 10개의 이동할 수 없는 부분 배열은 [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], 그리고 [1,2,3,4]입니다. 
이 중 어떤 부분 배열을 제거해도 nums는 엄격히 증가하게 됩니다. 비어있는 부분 배열을 선택할 수는 없습니다.



예제 2:
입력: nums = [6,5,7,8]
출력: 7
설명: 7개의 이동할 수 없는 부분 배열은 [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] 그리고 [6,5,7,8]입니다.
nums에서 이동할 수 없는 부분 배열이 7개밖에 없음을 보여줄 수 있습니다.
예제 3:



입력: nums = [8,7,6,6]
출력: 3
설명: 3개의 이동할 수 없는 부분 배열은 [8,7,6], [7,6,6], 그리고 [8,7,6,6]입니다. [8,7]은 이동할 수 없는 부분 배열이 아닙니다. 
왜냐하면 [8,7]을 제거한 후 nums는 [6,6]이 되며, 이는 오름차순으로 정렬되어 있지만 엄격히 증가하지는 않기 때문입니다.


제약 사항:
1 <= nums.length <= 50
1 <= nums[i] <= 50




요약:
어떤 부분 배열을 제거했을 때 주어진 배열 nums가 엄격하게 증가하는 형태가 되면, 그 부분 배열을 '이동할 수 없는 부분 배열'이라고 합니다. 
nums 배열에서 가능한 모든 '이동할 수 없는 부분 배열'의 개수를 찾는 문제입니다.



문제풀이 방향:
주어진 배열에서 모든 가능한 부분 배열을 찾아내야 합니다.
각 부분 배열을 제거했을 때 남는 배열이 엄격히 증가하는지 확인해야 합니다.
엄격히 증가하는지를 확인하기 위해선, 제거된 부분 배열의 앞뒤 요소들이 증가하는 순서를 유지하는지를 검사해야 합니다.
모든 부분 배열에 대해 위의 검사를 진행하고, 조건을 만족하는 부분 배열의 수를 계산합니다.


이 문제는 어떤 숫자 배열(nums)에서 특정 연속된 숫자들을 선택하여 제거했을 때, 남은 배열의 숫자들이 엄격히 증가하는 순서를 가지는지를 확인하는 것입니다. 
여기서 '엄격히 증가한다'는 말은 배열의 각 숫자가 이전 숫자보다 반드시 크다는 뜻입니다. 즉, 같은 숫자가 연속으로 있으면 안 됩니다.

예를 들어보겠습니다:

배열 [1,2,3,4]가 주어졌다고 합시다. 이 배열은 이미 엄격히 증가하는 순서이기 때문에, 
이 배열의 어떤 숫자를 제거해도 남은 배열은 여전히 엄격히 증가할 것입니다. 그래서 가능한 '이동할 수 없는 부분 배열'의 수는 배열의 모든 부분 배열입니다.

만약 배열이 [6,5,7,8]이라면, '5'를 제거하면 [6,7,8]이 되고, 이는 엄격히 증가합니다. 
하지만 '7'을 제거하면 [6,5,8]이 되고, 이는 '5' 다음에 '6'이 오기 때문에 엄격히 증가하는 배열이 아닙니다.

문제를 풀 때는 다음과 같은 단계를 거쳐야 합니다:

배열 내의 모든 가능한 부분 배열을 찾습니다.
각 부분 배열을 하나씩 제거하고, 제거 후 남은 배열이 엄격히 증가하는지 확인합니다.
엄격히 증가하는 경우를 카운트하고, 모든 부분 배열에 대해 이 과정을 반복합니다.
최종적으로 카운트된 '이동할 수 없는 부분 배열'의 수를 답으로 제시합니다.
문제를 해결하기 위한 알고리즘이나 데이터 구조를 사용하여, 효율적으로 모든 경우의 수를 탐색하고 계산해야 합니다.




*/

// https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/description/
