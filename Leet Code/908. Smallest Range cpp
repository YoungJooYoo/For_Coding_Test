class Solution {
public:
    int smallestRangeI(vector<int>& nums, int k) 
    {
        auto [min_it, max_it] = minmax_element(nums.begin(), nums.end());
  
        return max((*max_it - *min_it) - (2 * k), 0);
    }
};

/*
### 문제 번역

908. 가장 작은 범위 I
난이도: 쉬움
회사: (정보 없음)

정수 배열 `nums`와 정수 `k`가 주어집니다.

한 번의 연산에서, 0 <= i < nums.length를 만족하는 인덱스 i를 선택하고 `nums[i]`를 `nums[i] + x`로 변경할 수 있습니다. 여기서 x는 [-k, k] 범위의 정수입니다. 각 인덱스 i에 대해 이 연산을 최대 한 번 적용할 수 있습니다.

`nums`의 점수는 `nums` 내의 최대 요소와 최소 요소 사이의 차이입니다.

언급된 연산을 각 인덱스에서 최대 한 번 적용한 후 `nums`의 최소 점수를 반환하세요.

#### 예제 1:
입력: nums = [1], k = 0
출력: 0
설명: 점수는 max(nums) - min(nums) = 1 - 1 = 0 입니다.

#### 예제 2:
입력: nums = [0,10], k = 2
출력: 6
설명: nums를 [2, 8]로 변경합니다. 점수는 max(nums) - min(nums) = 8 - 2 = 6 입니다.

#### 예제 3:
입력: nums = [1,3,6], k = 3
출력: 0
설명: nums를 [4, 4, 4]로 변경합니다. 점수는 max(nums) - min(nums) = 4 - 4 = 0 입니다.

#### 제약 조건:
- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 10^4
- 0 <= k <= 10^4

---

### 요약본
**문제**: 주어진 배열 `nums`의 각 요소에 대해 최대 한 번, [-k, k] 범위의 값을 더하거나 뺄 수 있습니다. 이 연산을 적용한 후 `nums`의 최대값과 최소값의 차이(점수)를 최소화하는 값을 찾아야 합니다.

**제약 조건**: 
- 배열의 길이는 1 이상 10^4 이하입니다.
- 배열의 각 요소는 0 이상 10^4 이하입니다.
- k의 값은 0 이상 10^4 이하입니다.

---

### 문제 풀이 방향
이 문제의 핵심은 배열 내의 최대값과 최소값의 차이를 최소화하는 것입니다. 

1. **배열의 최대값과 최소값 찾기**: 먼저, 배열 `nums`에서 최대값과 최소값을 찾습니다.

2. **차이 계산**: 최대값과 최소값의 차이를 계산합니다.

3. **k를 사용하여 차이 조절**: 차이가 `2k` 이상인 경우, 최대값에서 `k`를 빼고 최소값에 `k`를 더하여 차이를 줄일 수 있습니다. 그 결과, 최소 점수는 `max(nums) - k - (min(nums) + k)`가 됩니다.

4. **차이가 `2k` 미만인 경우**: 만약 최대값과 최소값의 차이가 `2k` 미만이라면, 모든 요소를 같게 만들 수 있으므로 최소 점수는 0이 됩니다.

5. **결과 반환**: 계산된 최소 점수를 반환합니다.

이 방법으로, 주어진 `k` 값을 이용하여 배열 `nums`의 점수를 최소화할 수 있습니다.

*/


// https://leetcode.com/problems/smallest-range-i/description/
