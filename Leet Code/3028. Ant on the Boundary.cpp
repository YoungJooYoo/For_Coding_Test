class Solution {
public:
    int returnToBoundaryCount(vector<int>& nums) 
    {
        int count = 0; // 경계선으로 돌아온 횟수를 카운트할 변수
        int position = 0; // 개미의 현재 위치를 나타내는 변수, 경계선에서 시작
        
        // nums 배열을 순회하며 개미의 위치 업데이트
        for (int i = 0; i < nums.size(); ++i) {
            position += nums[i]; // nums[i]의 값에 따라 위치 업데이트
            
            // 만약 개미의 현재 위치가 경계선(0)이면 카운트 증가
            if (position == 0) {
                ++count;
            }
        }
        
        return count; // 경계선으로 돌아온 횟수 반환
    }
};

// https://leetcode.com/problems/ant-on-the-boundary/

/*

### 한국어 번역

3028. 경계선 위의 개미
난이도: 쉬움
주제: [정보 없음]
회사: [정보 없음]
힌트: [정보 없음]

한 개미가 경계선 위에 있습니다. 이 개미는 때때로 왼쪽으로, 때때로 오른쪽으로 이동합니다.

0이 아닌 정수들의 배열 `nums`가 주어집니다. 개미는 `nums`의 첫 번째 요소부터 시작하여 끝까지 읽습니다. 각 단계마다, 현재 요소의 값에 따라 이동합니다:

- 만약 `nums[i] < 0`이라면, 개미는 `-nums[i]` 단위만큼 왼쪽으로 이동합니다.
- 만약 `nums[i] > 0`이라면, 개미는 `nums[i]` 단위만큼 오른쪽으로 이동합니다.

개미가 경계선으로 돌아온 횟수를 반환하세요.

노트:

- 경계선의 양쪽에는 무한한 공간이 있습니다.
- 개미가 `|nums[i]|` 단위만큼 이동한 후에만 개미가 경계선 위에 있는지를 확인합니다. 다시 말해, 개미가 이동하는 동안 경계선을 넘어섰다면, 그것은 카운트되지 않습니다.

### 요약

개미가 경계선으로부터 왼쪽 또는 오른쪽으로 이동하는 정수 배열이 주어졌을 때, 개미가 경계선으로 돌아온 횟수를 계산하는 문제입니다.

### 문제 풀이 방향

1. **위치 추적**: 개미의 현재 위치를 추적하기 위한 변수를 선언합니다. 초기 위치는 경계선, 즉 0으로 설정합니다.

2. **배열 순회**: `nums` 배열을 순회하면서 개미의 위치를 업데이트합니다. `nums[i]`의 값에 따라 개미의 위치를 왼쪽 또는 오른쪽으로 이동시킵니다.

3. **경계선 도착 확인**: 각 이동 후, 개미의 위치가 0(경계선)으로 돌아왔는지 확인합니다. 돌아온 경우, 카운터를 증가시킵니다.

4. **결과 반환**: 모든 `nums` 요소에 대한 처리가 완료된 후, 경계선으로 돌아온 횟수를 나타내는 카운터를 반환합니다.

이 문제의 핵심은 개미의 이동을 정확하게 추적하고, 각 이동 후의 위치를 기반으로 개미가 경계선으로 돌아온 횟수를 세는 것입니다.

*/
