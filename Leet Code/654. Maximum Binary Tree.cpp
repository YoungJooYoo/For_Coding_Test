class Solution {
public:
    TreeNode* buildMaximumBinaryTree(const vector<int>& nums, const int left, const int right) 
    {
        if (left >= right) {
            return nullptr;
        }

        const int maxPos = std::max_element(nums.begin() + left, nums.begin() + right) - nums.begin(); // 서브 어레이에서 최대값을 지속적으로 구함
        TreeNode* const root = new TreeNode(nums[maxPos]); // 각 서브 어레이의 루트 생성
        
        root->left = buildMaximumBinaryTree(nums, left, maxPos);
        root->right = buildMaximumBinaryTree(nums, maxPos + 1, right);

        return root;
    }

    TreeNode* constructMaximumBinaryTree(const vector<int>& nums) 
    {
        return buildMaximumBinaryTree(nums, 0, nums.size());
    }
};


// https://leetcode.com/problems/maximum-binary-tree/description/

/*

### 한국어 번역

654. 최대 이진 트리
난이도: 중간
주제: [정보 없음]
회사: [정보 없음]
중복이 없는 정수 배열 `nums`가 주어집니다. 다음 알고리즘을 사용하여 `nums`에서 최대 이진 트리를 재귀적으로 구축할 수 있습니다:

1. 루트 노드를 생성하며, 그 값은 `nums`의 최대값입니다.
2. 최대값의 왼쪽에 있는 서브어레이 접두사(prefix)에 대해 재귀적으로 왼쪽 서브트리를 구축합니다.
3. 최대값의 오른쪽에 있는 서브어레이 접미사(suffix)에 대해 재귀적으로 오른쪽 서브트리를 구축합니다.
4. `nums`로부터 구축된 최대 이진 트리를 반환합니다.

#### 예시 1:

입력: nums = [3,2,1,6,0,5]
출력: [6,3,5,null,2,0,null,null,1]
설명: 재귀 호출은 다음과 같습니다:
- [3,2,1,6,0,5]에서 가장 큰 값은 6입니다. 왼쪽 접두사는 [3,2,1]이고, 오른쪽 접미사는 [0,5]입니다.
    - [3,2,1]에서 가장 큰 값은 3입니다. 왼쪽 접두사는 []이고, 오른쪽 접미사는 [2,1]입니다.
        - 빈 배열이므로 자식 노드가 없습니다.
        - [2,1]에서 가장 큰 값은 2입니다. 왼쪽 접두사는 []이고, 오른쪽 접미사는 [1]입니다.
            - 빈 배열이므로 자식 노드가 없습니다.
            - 하나의 요소만 있으므로 자식은 값이 1인 노드입니다.
    - [0,5]에서 가장 큰 값은 5입니다. 왼쪽 접두사는 [0]이고, 오른쪽 접미사는 []입니다.
        - 하나의 요소만 있으므로 자식은 값이 0인 노드입니다.
        - 빈 배열이므로 자식 노드가 없습니다.

#### 예시 2:

입력: nums = [3,2,1]
출력: [3,null,2,null,1]

#### 제약 조건:

- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 1000
- `nums`의 모든 정수는 고유합니다.

### 요약

주어진 배열 `nums`를 사용하여 최대값을 루트 노드로 하는 최대 이진 트리를 재귀적으로 구축하는 문제입니다.

### 문제 풀이 방향

1. **분할 정복 접근**: 배열을 순회하며 최대값을 찾고, 이를 루트 노드로 설정합니다.

2. **재귀 함수 구현**: 최대값을 기준으로 배열을 왼쪽과 오른쪽 서브어레이로 분할하고, 각각에 대해 재귀적으로 최대 이진 트리를 구축합니다.

3. **기저 사례 처리**: 빈 배열 또는 하나의 요소만 있는 배열에 대한 처리를 포함합니다.

4. **트리 노드 정의**: 이진 트리를 구성하는 노드 클래스를 정의합니다. 각 노드는 값, 왼쪽 자식, 오른쪽 자식을 가집니다.



이 문제는 배열을 이용해 특별한 종류의 이진 트리, 즉 "최대 이진 트리"를 만드는 문제입니다. 이 문제를 쉽게 설명하자면 다음과 같습니다:

주어진 배열에서 가장 큰 숫자를 찾습니다. 이 숫자가 이진 트리의 루트(뿌리) 노드가 됩니다.
이 최대값을 중심으로 배열을 두 부분으로 나눕니다: 최대값의 왼쪽에 있는 모든 숫자들로 구성된 부분과 오른쪽에 있는 모든 숫자들로 구성된 부분입니다.
이제, 이 두 부분 배열을 각각 똑같은 방식으로 다룹니다. 즉, 각 부분 배열에서 가장 큰 숫자를 찾고, 이를 각각 왼쪽 자식 노드와 오른쪽 자식 노드로 만듭니다.
이 과정을 배열에 더 이상 숫자가 없을 때까지 반복합니다.
결과적으로, 이 트리에서는 모든 노드가 자신의 자식 노드들보다 큰 값을 가지게 됩니다. 예를 들어, 배열이 [3,2,1,6,0,5]라면, 가장 큰 값인 6이 루트 노드가 되고, 6의 왼쪽에 [3,2,1]이 오른쪽에 [0,5]가 위치하게 되어, 이 부분들도 같은 방식으로 트리를 구성하게 됩니다.


*/
