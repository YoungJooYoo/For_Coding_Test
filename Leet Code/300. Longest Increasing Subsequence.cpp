class Solution {
public:
    int lengthOfLIS(const vector<int>& nums) 
    {
        const size_t LEN = nums.size();

        if (LEN == 0) {
            return 0;
        }

        vector<int> dp(LEN, 1); // 각 인덱스에서 끝나는 최장 증가 부분 수열의 길이를 저장
        int maxLen = 1; // 최대 부분 수열 길이 초기화

        for (int i = 1; i < LEN; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    // 현재 원소가 이전 원소보다 큰 경우, dp 배열 업데이트
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            maxLen = max(maxLen, dp[i]); // 최대 길이 업데이트
        }

        return maxLen;
    }
};


/*

번역: 
정수 배열 nums가 주어졌을 때, 가장 긴 엄격히 증가하는 부분 수열의 길이를 반환하세요.

예시 1: 입력: nums = [10,9,2,5,3,7,101,18], 출력: 4 (설명: 가장 긴 증가 부분 수열은 [2,3,7,101]이므로 길이는 4입니다.)
예시 2: 입력: nums = [0,1,0,3,2,3], 출력: 4
예시 3: 입력: nums = [7,7,7,7,7,7,7], 출력: 1


요약: 
이 문제는 주어진 배열에서 가장 긴 증가하는 부분 수열의 길이를 찾는 것입니다.


문제 풀이 방향: 
동적 프로그래밍(Dynamic Programming)을 사용하여 각 인덱스에서 끝나는 가장 긴 증가하는 부분 수열의 길이를 계산합니다. 배열의 각 원소에 대해, 그 원소보다 작은 모든 이전 원소들을 탐색하고, 그 중 가장 긴 증가하는 부분 수열의 길이를 찾아 현재 원소를 추가합니다. 이렇게 모든 원소에 대해 계산한 후, 계산된 부분 수열 길이 중 최대값을 반환합니다.


*/
