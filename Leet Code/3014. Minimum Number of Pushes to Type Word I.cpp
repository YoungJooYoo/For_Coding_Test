class Solution {
public:
    int minimumPushes(string word) 
    {
        vector<int> freq(ALPHA_LENGTH, 0);
        int ans = 0;

        for (const char c : word) {
            ++freq[c - 'a'];
        }

        sort(freq.begin(), freq.end(), greater<int>()); // 빈도수에 따라 내림차순으로 정렬

        for (size_t i = 0; i < ALPHA_LENGTH; ++i) {
            ans += freq[i] * ((i / 8) + 1); // 키 누름 횟수 계산
        }

        return ans;
    }

private:
    enum { ALPHA_LENGTH = 26 };
};

// https://leetcode.com/problems/minimum-number-of-pushes-to-type-word-i/description/

/*
### 한국어 번역

3014. 단어 입력을 위한 최소 키 누름 횟수 I
난이도: 쉬움
회사: [정보 없음]
힌트: 서로 다른 소문자 영문자로 구성된 문자열 `word`가 주어집니다.

전화 키패드에는 소문자 영문자의 서로 다른 조합이 매핑되어 있으며, 이를 통해 키를 눌러 단어를 형성할 수 있습니다. 예를 들어, 키 2는 ["a", "b", "c"]로 매핑되어 있어 "a"를 입력하기 위해서는 한 번, "b"를 입력하기 위해서는 두 번, "c"를 입력하기 위해서는 세 번 눌러야 합니다.

2부터 9까지의 키를 영문자의 서로 다른 조합으로 재매핑할 수 있습니다. 키는 임의의 수의 문자에 매핑될 수 있지만, 각 문자는 정확히 하나의 키에만 매핑되어야 합니다. 문자열 `word`를 입력하기 위한 최소 키 누름 횟수를 찾아야 합니다.

재매핑 후 `word`를 입력하기 위한 최소 키 누름 횟수를 반환하세요.

전화 키패드에 문자를 매핑하는 예시는 아래와 같습니다. 1, *, #, 0은 어떤 문자에도 매핑되지 않는다는 점에 유의하세요.

#### 예시 1:

입력: word = "abcde"
출력: 5
설명: 이미지에 제시된 재매핑된 키패드가 최소 비용을 제공합니다.
"a" -> 키 2를 한 번 누름
"b" -> 키 3를 한 번 누름
"c" -> 키 4를 한 번 누름
"d" -> 키 5를 한 번 누름
"e" -> 키 6를 한 번 누름
총 비용은 1 + 1 + 1 + 1 + 1 = 5입니다.
다른 매핑이 더 낮은 비용을 제공할 수 없음을 보여줄 수 있습니다.

#### 예시 2:

입력: word = "xycdefghij"
출력: 12
설명: 이미지에 제시된 재매핑된 키패드가 최소 비용을 제공합니다.
"x" -> 키 2를 한 번 누름
"y" -> 키 2를 두 번 누름
"c" -> 키 3를 한 번 누름
"d" -> 키 3를 두 번 누름
"e" -> 키 4를 한 번 누름
"f" -> 키 5를 한 번 누름
"g" -> 키 6를 한 번 누름
"h" -> 키 7를 한 번 누름
"i" -> 키 8를 한 번 누름
"j" -> 키 9를 한 번 누름
총 비용은 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12입니다.
다른 매핑이 더 낮은 비용을 제공할 수 없음을 보여줄 수 있습니다.

#### 제약 조건:

- 1 <= word.length <= 26
- word는 소문자 영문자로 구성됩니다.
- word의 모든 문자는 서로 다릅니다.

### 요약

이 문제는 주어진 문자열 `word`를 입력하기 위한 키 누름의 최소 횟수를 찾는 것입니다. 각 키는 소문자 영문자의 서로 다른 조합으로 재매핑될 수 있으며, 각


이 문제 풀이 방법은 문자열 word에서 각 문자의 빈도를 계산하고, 이 빈도에 따라 키 누름 횟수를 최소화하는 방식입니다. 먼저 각 문자의 빈도를 계산한 후, 이를 내림차순으로 정렬합니다. 상위 8개의 문자는 한 번의 키 누름으로 입력되고, 그 다음 8개는 두 번의 키 누름, 그 다음 8개는 세 번의 키 누름 등으로 처리됩니다. 각 문자의 빈도와 해당 문자를 입력하기 위해 필요한 키 누름 횟수를 곱하여 최종 답을 계산합니다.

복잡도 분석
시간 복잡도: 이 코드의 시간 복잡도는 O(N log N)입니다. 여기서 N은 입력 문자열의 길이입니다. 빈도를 계산하는 데 O(N)의 시간이 걸리고, 이를 정렬하는 데 O(N log N)의 시간이 걸립니다.
공간 복잡도: O(1)입니다. 입력 문자열의 크기에 상관없이 상수 크기의 추가 공간(26개 요소를 가진 freq 벡터)만 사용하기 때문입니다.

*/
