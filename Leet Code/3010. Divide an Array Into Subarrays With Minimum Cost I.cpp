class Solution {
public:
    int minimumCost(vector<int>& nums) 
    {
        sort(nums.begin() + 1,nums.end());

        return nums[0] + nums[1] + nums[2];
    }
};


// https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/description/

/*

### 번역

3010. 최소 비용으로 배열을 서브어레이로 나누기 I
난이도: 쉬움
회사: [정보 없음]

길이가 `n`인 정수 배열 `nums`가 주어집니다.

배열의 비용은 그 배열의 첫 번째 요소의 값입니다. 예를 들어, [1,2,3]의 비용은 1이며, [3,4,1]의 비용은 3입니다.

`nums`를 3개의 분리된 연속 서브어레이로 나누어야 합니다.

이 서브어레이들의 비용 합계의 최소값을 반환하세요.

#### 예시 1:

입력: nums = [1,2,3,12]
출력: 6
설명: 3개의 서브어레이를 만드는 최선의 방법은 [1], [2], [3,12]이며, 전체 비용은 1 + 2 + 3 = 6입니다.
3개의 서브어레이를 만드는 다른 방법들은 다음과 같습니다:
- [1], [2,3], [12]로 비용은 1 + 2 + 12 = 15.
- [1,2], [3], [12]로 비용은 1 + 3 + 12 = 16.

#### 예시 2:

입력: nums = [5,4,3]
출력: 12
설명: 3개의 서브어레이를 만드는 최선의 방법은 [5], [4], [3]이며, 전체 비용은 5 + 4 + 3 = 12입니다.
12가 달성 가능한 최소 비용임을 보여줄 수 있습니다.

#### 예시 3:

입력: nums = [10,3,1,1]
출력: 12
설명: 3개의 서브어레이를 만드는 최선의 방법은 [10,3], [1], [1]이며, 전체 비용은 10 + 1 + 1 = 12입니다.
12가 달성 가능한 최소 비용임을 보여줄 수 있습니다.

#### 제약 조건:

- 3 <= n <= 50
- 1 <= nums[i] <= 50





### 요약

이 문제에서는 주어진 정수 배열 `nums`를 3개의 연속된 서브어레이로 나누는 문제입니다. 각 서브어레이의 비용은 그 서브어레이의 첫 번째 요소의 값으로 정의됩니다. 목표는 이 서브어레이들의 비용 합계를 최소화하는 것입니다.





### 문제 풀이 방향

1. **브루트 포스 접근**: 가능한 모든 서브어레이 분할을 시도하고 각각의 총 비용을 계산합니다. 이 방법은 시간 복잡도가 높지만, 작은 입력 크기에는 효과적일 수 있습니다.

2. **동적 프로그래밍 (DP)**: 이 문제는 최적 부분 구조를 가지고 있어 동적 프로그래밍으로 접근할 수 있습니다. 각 단계에서 최소 비용을 계산하고 저장하여, 전체 문제의 최소 비용을 효율적으로 찾을 수 있습니다.

3. **누적 합 계산**: 배열의 누적 합을 미리 계산하여 서브어레이의 합을 빠르게 구할 수 있습니다. 이는 동적 프로그래밍과 결합하여 계산 시간을 줄일 수 있습니다.

4. **서브어레이 분할 결정**: 배열을 3개의 서브어레이로 나누는 각 분할 지점에 대해 최소 비용을 계산합니다

*/
