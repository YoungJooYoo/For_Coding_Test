class Solution 
{
public:
    int matrixMedian(const vector<vector<int>>& grid) 
    {
        vector<int> nums;

        for (const auto& row : grid)
        {
            for (const auto& num : row)
            {
                nums.push_back(num);
            }
        }
        
        sort(nums.begin(), nums.end());

        return nums[nums.size() / 2];
    }
};

// https://leetcode.com/problems/median-of-a-row-wise-sorted-matrix/description/

/*

2387. 행별로 정렬된 행렬의 중앙값
중간 난이도

주제

기업

주어진 m x n 행렬 grid에는 홀수 개의 정수가 포함되어 있으며, 각 행은 비감소 순서로 정렬되어 있습니다. 이 행렬의 중앙값을 반환하세요.

중앙값은 전체 요소를 정렬했을 때 중앙에 위치한 값을 의미합니다.

문제를 **O(m * n)**보다 낮은 시간 복잡도로 해결해야 합니다.

예제 1:
lua
코드 복사
입력: grid = [[1,1,2],[2,3,3],[1,3,4]]
출력: 2
설명:
행렬의 모든 요소를 정렬하면 [1,1,1,2,2,3,3,3,4]가 됩니다. 중앙값은 2입니다.
예제 2:
lua
코드 복사
입력: grid = [[1,1,3,3,4]]
출력: 3
설명:
행렬의 모든 요소를 정렬하면 [1,1,3,3,4]가 됩니다. 중앙값은 3입니다.
제약 사항:
m == grid.length
n == grid[i].length
1 <= m, n <= 500
m과 n은 모두 홀수입니다.
1 <= grid[i][j] <= 10^6
grid[i]는 비감소 순서로 정렬되어 있습니다.
📚 추가 설명 및 힌트
이 문제는 이진 탐색을 활용하여 효율적으로 해결할 수 있습니다. 특히, 각 행이 이미 정렬되어 있다는 점을 활용하면 시간 복잡도를 줄일 수 있습니다.

🔍 힌트:
이진 탐색 활용:

가능한 중앙값의 범위를 설정하고, 이 범위 내에서 이진 탐색을 수행합니다.
중간값을 기준으로 각 행에서 중간값 이하의 요소 개수를 효율적으로 계산할 수 있습니다.
행별 정렬 상태 이용:

각 행이 정렬되어 있으므로, 특정 값 이하의 요소 개수를 이진 탐색을 통해 빠르게 찾을 수 있습니다.
중앙값 정의:

행렬의 모든 요소가 홀수 개이므로, 중앙값은 정확히 하나의 값입니다.
시간 복잡도 최적화:

전체 요소를 정렬하는 방법은 시간 복잡도가 **O(m * n * log(m * n))**으로 비효율적일 수 있습니다.
대신, 이진 탐색을 사용하여 시간 복잡도를 **O(m * log(max - min) * log n)**으로 줄일 수 있습니다.
🛠 구체적인 접근 방법:
가능한 값의 범위 설정:

행렬 내 최솟값과 최댓값을 찾습니다.
중앙값은 이 범위 내에 존재합니다.
이진 탐색 수행:

최솟값과 최댓값의 중간값을 중앙값 후보로 설정합니다.
각 행에서 중앙값 후보 이하의 요소 개수를 이진 탐색을 통해 계산합니다.
전체 행에서 중앙값 후보 이하의 요소 개수를 합산하여 중앙값 위치와 비교합니다.
중앙값 후보가 중앙값보다 크면 범위를 줄이고, 작으면 범위를 늘립니다.
중앙값 결정:

이진 탐색을 통해 중앙값을 정확히 찾을 때까지 반복합니다.
*/
