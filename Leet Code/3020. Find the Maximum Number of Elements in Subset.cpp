class Solution {
public:
    int maximumLength(vector<int>& nums) 
    {
        unordered_map<long long, int> freq;
        unordered_map<long long, int> dp;
        sort(nums.begin(), nums.end()); // 작은 요소부터 처리하기 위해 nums 배열을 정렬
        
        // 빈도 맵 초기화 및 dp 맵 초기화
        for (const auto& num : nums) 
        {
            ++freq[num];      // 각 요소의 빈도수 저장
            dp[num] = 1;      // 각 요소의 dp 값을 1로 초기화
        }

        // 답변을 1의 개수 또는 가장 큰 홀수 개수로 초기화
        int ans = (freq[1] & 1) ? freq[1] : freq[1] - 1;

        // 정렬된 nums 배열의 각 요소를 순회
        for (const long long& x : nums) 
        {
            // {x, x^2, x}와 같은 부분 집합이 존재할 수 있는지 확인
            if (x != 1 && freq[x] >= 2 && freq[x * x] > 0) 
            {
                dp[x * x] = max(dp[x * x], 2 + dp[x]); // 제곱된 요소에 대한 dp 값 업데이트
                ans = max(ans, dp[x * x]); // 최대값으로 ans 업데이트
            }
        }

        return max(1, ans); // 최소값이 1인 최종 결과 반환
    }
};

// https://leetcode.com/problems/find-the-maximum-number-of-elements-in-subset/?envType=company&envId=google&favoriteSlug=google-thirty-days

/*

### **3020. 부분 집합에서 요소의 최대 개수 찾기**

양의 정수 배열 `nums`가 주어집니다.
다음 조건을 만족하는 `nums`의 부분 집합을 선택해야 합니다:
선택된 요소들을 0 인덱스 배열에 다음과 같은 패턴으로 배치할 수 있어야 합니다
: `[x, x², x⁴, ..., x^{k/2}, x^k, x^{k/2}, ..., x⁴, x², x]` (단, `k`는 2의 거듭제곱인 임의의 비음수일 수 있습니다). 예를 들어, `[2, 4, 16, 4, 2]`와 `[3, 9, 3]`은 패턴을 따르지만 `[2, 4, 8, 4, 2]`는 따르지 않습니다.
이러한 조건을 만족하는 부분 집합의 최대 요소 수를 반환하세요.

---

**예시 1:**

```
입력: nums = [5,4,1,2,2]
출력: 3
설명: 우리는 {4,2,2} 부분 집합을 선택할 수 있으며, 이는 [2,4,2] 배열로 배치할 수 있습니다. 이는 패턴을 따르며 2² == 4입니다. 따라서 정답은 3입니다.
```

**예시 2:**

```
입력: nums = [1,3,2,4]
출력: 1
설명: 우리는 {1} 부분 집합을 선택할 수 있으며, 이는 [1] 배열로 배치할 수 있습니다. 이는 패턴을 따릅니다. 따라서 정답은 1입니다. 또한 {2}, {3}, {4} 부분 집합도 선택할 수 있으며, 동일한 정답을 제공하는 여러 부분 집합이 있을 수 있습니다.
```

**제약 사항:**

- 2 <= `nums.length` <= 10⁵
- 1 <= `nums[i]` <= 10⁹



### **추가 설명:**

이 문제는 주어진 배열 `nums`에서 특정한 패턴을 만족하는 최대 크기의 부분 집합을 찾는 것입니다. 패턴은 대칭적이며, 가운데를 기준으로 값이 증가한 후 다시 감소하는 형태를 가집니다. 예를 들어, `[2, 4, 16, 4, 2]`는 2에서 시작해 4, 16으로 증가한 후 다시 4, 2로 감소하며 대칭을 이룹니다.

해결 방법은 주어진 배열에서 가능한 모든 부분 집합을 탐색하는 것이 아니라, 효율적으로 패턴을 만족하는 최대 부분 집합을 찾는 알고리즘을 설계하는 것입니다. 이를 위해 해시맵이나 동적 프로그래밍과 같은 기법을 활용할 수 있습니다.

더욱 효율적인 해결책을 위해 문제의 조건과 예제를 잘 분석하고, 주어진 제한 사항 내에서 최적의 성능을 발휘할 수 있는 알고리즘을 구현하는 것이 중요합니다.



힌트 1
1의 개수를 홀수로 선택할 수 있습니다.

힌트 2
모든 값을 HashSet에 넣습니다. 각 x > 1을 가장 작은 선택된 값으로 시작할 수 있으며, 이전 값의 제곱인 새로운 값들을 집합에서 브루트 포스로 확인하여 가장 긴 부분 집합을 찾을 수 있습니다.

힌트 3
x > 1일 때, x^2, x^4, x^8, …는 매우 빠르게 증가하므로, 가장 작은 값 x로 시작하는 가장 긴 부분 집합의 길이는 매우 길지 않을 수 있습니다. (길이는 O(log(log(10^9)))입니다.)

힌트 4
따라서 x의 모든 값에 대해 길이가 10보다 작은 경우를 직접 확인할 수 있습니다.


*/
