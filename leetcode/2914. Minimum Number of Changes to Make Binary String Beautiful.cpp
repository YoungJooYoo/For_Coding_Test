class Solution 
{
public:
    int minChanges(const string& s) 
    {
        const size_t LENGTH = s.size();
        int count = 0;

        assert(LENGTH % 2 == 0);

        for (size_t i = 1; i < LENGTH; i = i + 2)
        {
            if (s[i -1] != s[i])
            {
                ++count;
             }
        }

        return count;
    }
};

// https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/description/?envType=daily-question&envId=2024-11-05

/*

물론입니다. 아래는 해당 LeetCode 문제의 한국어 번역입니다:

---

**2914. 이진 문자열을 아름답게 만들기 위한 최소 변경 횟수**  
난이도: 중간

---

0부터 시작하는 인덱스를 가진 짝수 길이의 이진 문자열 `s`가 주어집니다.

문자열이 "아름답다(beautiful)"고 하려면, 다음 조건을 만족하는 하나 이상의 부분 문자열로 나눌 수 있어야 합니다:

1. 각 부분 문자열은 짝수 길이를 가져야 합니다.
2. 각 부분 문자열은 오직 `1`로만 이루어져 있거나 오직 `0`으로만 이루어져 있어야 합니다.

문자열 `s`의 각 문자를 `0` 또는 `1`로 변경할 수 있습니다.

문자열 `s`를 아름답게 만들기 위해 필요한 최소 변경 횟수를 반환하세요.

---

### 예제 1:

입력: 
```
s = "1001"
```
출력: 
```
2
```
설명:
- `s[1]`을 `1`로, `s[3]`을 `0`으로 변경하여 `"1100"`을 얻습니다.
- 문자열 `"1100"`은 `"11|00"`으로 나눌 수 있으므로 아름답습니다.
- `2`가 최소 변경 횟수임을 증명할 수 있습니다.

### 예제 2:

입력: 
```
s = "10"
```
출력: 
```
1
```
설명:
- `s[1]`을 `1`로 변경하여 `"11"`을 얻습니다.
- 문자열 `"11"`은 자체로 아름답습니다.
- `1`이 최소 변경 횟수임을 증명할 수 있습니다.

### 예제 3:

입력: 
```
s = "0000"
```
출력: 
```
0
```
설명:
- 문자열 `"0000"`은 이미 아름답기 때문에 변경이 필요하지 않습니다.

---

### 제약 사항:

- `2 <= s.length <= 10^5`
- `s`의 길이는 짝수입니다.
- `s[i]`는 `'0'` 또는 `'1'`입니다.
*/
