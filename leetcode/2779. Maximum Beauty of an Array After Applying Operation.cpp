class Solution 
{
public:
    int maximumBeauty(vector<int>& nums, const int k) 
    {
        sort(nums.begin(), nums.end()); // 정렬
        int left = 0;
        int maxFreq = 0;
        
        for (int right = 0; right < nums.size(); ++right) // 슬라이딩 윈도우로 범위 내 숫자 계산
        {
            while (nums[right] - nums[left] > 2 * k) // 범위를 벗어나는 숫자를 윈도우에서 제외 
            {
                ++left;
            }
            maxFreq = max(maxFreq, right - left + 1); // 현재 윈도우의 크기가 범위 내 숫자의 개수
        }

        return maxFreq;
    }
};

// https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/?envType=daily-question&envId=2024-12-11

/*
### 문제 번역: 

#### **2779. 배열의 최대 아름다움 계산 (운영 적용 후)**

**난이도:** 중간  
**제약 사항:**  
- 0-인덱스 정수 배열 `nums`와 비음수 정수 `k`가 주어집니다.  

**연산:**  
다음과 같은 연산을 수행할 수 있습니다:  
1. `[0, nums.length - 1]` 범위에서 이전에 선택하지 않은 인덱스 `i`를 선택합니다.  
2. `nums[i]`를 `[nums[i] - k, nums[i] + k]` 범위의 임의의 정수로 교체합니다.

**목표:**  
배열 `nums`의 **아름다움(beauty)**은 동일한 요소로 구성된 가장 긴 부분 수열의 길이로 정의됩니다.  
연산을 여러 번 수행하여 배열의 최대 아름다움을 반환하세요.

**추가 정보:**  
- 각 인덱스는 최대 1회만 연산이 가능합니다.
- 배열의 부분 수열은 배열의 순서를 유지하면서 일부 요소를 삭제하여 생성된 새로운 배열입니다.

---

### **예제:**

#### **예제 1:**
```text
입력: nums = [4,6,1,2], k = 2
출력: 3
```

**설명:**
- 다음과 같이 연산을 적용합니다:  
  1. 인덱스 1 선택: `[4,6,1,2]`에서 `6`을 `[4,8]` 범위의 4로 교체 → `[4,4,1,2]`
  2. 인덱스 3 선택: `[4,4,1,2]`에서 `2`를 `[0,4]` 범위의 4로 교체 → `[4,4,1,4]`
- 최종 배열: `[4,4,1,4]`  
- 배열의 아름다움 = 3 (인덱스 0, 1, 3에서의 `4`).

---

#### **예제 2:**
```text
입력: nums = [1,1,1,1], k = 10
출력: 4
```

**설명:**
- 연산을 수행하지 않아도 모든 요소가 이미 동일합니다.
- 배열의 아름다움 = 4 (배열 전체).

---

### **제약 조건:**
1. `1 <= nums.length <= 10^5`
2. `0 <= nums[i], k <= 10^5`
*/
