class Solution {
public:
    int numberOfAlternatingGroups(const vector<int>& colors) 
    {
        const int n = colors.size();
        int count = 0;
        
        for (int i = 0; i < n; ++i) 
        {
            const int left = colors[i];
            const int middle = colors[(i + 1) % n];
            const int right = colors[(i + 2) % n];
            
            if (middle != left && middle != right) 
            {
                ++count;
            }
        }
        
        return count;
    }
};


// https://leetcode.com/problems/alternating-groups-i/description/

/*
### 문제 번역

**3206. 교차 그룹 I**

**난이도: 쉬움**

#### 문제 설명

빨간색과 파란색 타일로 이루어진 원형이 있습니다. 정수 배열 `colors`가 주어집니다. 타일 `i`의 색상은 `colors[i]`로 나타냅니다:

- `colors[i] == 0`이면 타일 `i`는 빨간색입니다.
- `colors[i] == 1`이면 타일 `i`는 파란색입니다.

원형에서 3개의 연속된 타일이 교차하는 색상(가운데 타일이 왼쪽과 오른쪽 타일과 다른 색상인 경우)을 교차 그룹이라고 합니다.

교차 그룹의 수를 반환하세요.

참고: `colors`가 원형을 나타내므로 첫 번째 타일과 마지막 타일도 서로 인접해 있다고 간주됩니다.

#### 예제

**예제 1**:

- 입력: `colors = [1,1,1]`
- 출력: `0`
- 설명: 모든 타일이 같은 색이므로 교차 그룹이 없습니다.

**예제 2**:

- 입력: `colors = [0,1,0,0,1]`
- 출력: `3`
- 설명: 
  - 인덱스 0-2: 0 1 0 (교차 그룹)
  - 인덱스 1-3: 1 0 0 (교차 그룹 아님)
  - 인덱스 2-4: 0 0 1 (교차 그룹)
  - 인덱스 3-5 (원형 고려): 0 1 0 (교차 그룹)

#### 제약 조건

- `3 <= colors.length <= 100`
- `0 <= colors[i] <= 1`

---

### 문제 풀이 방향

1. **배열을 순회하며 교차 그룹을 확인**:
   - 원형이므로 첫 번째와 마지막 타일이 인접해 있음을 고려해야 합니다.
   - 세 개의 연속된 타일을 확인하여 교차 그룹인지 확인합니다.
   - 교차 그룹의 조건: 가운데 타일이 양쪽 타일과 다른 색상인 경우.

2. **교차 그룹을 세는 알고리즘**:
   - 인덱스를 순회하며 현재 타일과 다음 두 개의 타일을 확인합니다.
   - 인덱스가 배열의 끝을 넘어갈 경우를 고려하여 모듈로 연산을 사용합니다.



### 코드 설명

1. **배열 순회**:
   - `colors` 배열을 순회하며 인덱스 `i`부터 시작하여 연속된 세 개의 타일을 확인합니다.
   - `middle` 타일이 `left`와 `right` 타일과 다른 경우를 교차 그룹으로 간주합니다.
   - 배열의 끝을 넘어갈 경우를 처리하기 위해 모듈로 연산을 사용합니다.

2. **결과 반환**:
   - 교차 그룹의 수를 세고 이를 반환합니다.

이 접근 방식은 원형 배열을 고려하여 모든 가능한 교차 그룹을 확인하고, 조건에 맞는 그룹의 수를 세는 효율적인 방법입니다.

*/
