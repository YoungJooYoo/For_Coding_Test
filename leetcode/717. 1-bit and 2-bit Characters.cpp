class Solution 
{
public:
    bool isOneBitCharacter(const vector<int>& bits) 
    {
        const int n = bits.size();
        int i = 0;

        while (i < n - 1) {
            if (bits[i] == 1) {
                i += 2;  // 두 비트 문자로 해석
            } else {
                i += 1;  // 한 비트 문자로 해석
            }
        }

        return (i == n - 1) ? true : false;  // 마지막 문자가 한 비트 문자인지 확인
    }
};

// https://leetcode.com/problems/1-bit-and-2-bit-characters/description/

/*

특수한 두 개의 문자 형태가 있습니다:

첫 번째 문자는 하나의 비트 0로 표현됩니다.
두 번째 문자는 두 개의 비트 (10) 또는 (11)로 표현됩니다.
0으로 끝나는 이진 배열 bits가 주어졌을 때, 마지막 문자가 반드시 1비트 문자인지 확인하여 true 또는 false를 반환하세요.

예제 1
입력: bits = [1,0,0]
출력: true
설명: 유일하게 해석할 수 있는 방법은 두 비트 문자(10)와 한 비트 문자(0)로 해석하는 것입니다. 따라서 마지막 문자는 한 비트 문자입니다.
예제 2
입력: bits = [1,1,1,0]
출력: false
설명: 유일하게 해석할 수 있는 방법은 두 비트 문자(11)와 두 비트 문자(10)로 해석하는 것입니다. 따라서 마지막 문자는 한 비트 문자가 아닙니다.
제약 조건
bits.length는 1 이상 1000 이하입니다.
bits[i]는 0 또는 1입니다.
문제 풀이
문제의 핵심은 배열을 순차적으로 읽어나가면서 각 비트가 어떤 문자로 해석될 수 있는지를 판단하는 것입니다. 마지막 문자가 반드시 1비트 문자인지 확인하기 위해 배열을 순차적으로 검사하는 방법을 사용합니다.

배열의 각 비트를 순차적으로 읽습니다.
현재 비트가 1이면 다음 두 비트를 검사하고 두 비트 문자로 해석합니다. 따라서 인덱스를 2 증가시킵니다.
현재 비트가 0이면 한 비트 문자로 해석하고 인덱스를 1 증가시킵니다.
마지막 문자가 한 비트 문자로 해석되었는지 확인합니다.
*/
