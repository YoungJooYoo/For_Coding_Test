class Solution 
{
public:
    const string getSmallestString(string& s) 
    {
        const size_t LENGTH = s.size();
        string minVal = s;
        string result;

        for (size_t i = 1; i < LENGTH; ++i)
        {
            if ((s[i - 1] - '0') % 2 == 0 && (s[i] - '0') % 2 == 0 ||
                (s[i - 1] - '0') % 2 == 1 && (s[i] - '0') % 2 == 1)
            {
                string temp = s;
                swap(temp[i - 1], temp[i]);
                minVal = min(minVal, temp);
            }
        }

        return minVal;   
    }
};

// https://leetcode.com/problems/lexicographically-smallest-string-after-a-swap/description/


/*

### 3216. 교환 후 사전 순으로 가장 작은 문자열

**난이도: 쉬움**

#### 문제 설명

숫자만 포함된 문자열 `s`가 주어졌을 때, 인접한 동일한 홀짝성을 가진 숫자들을 최대 한 번 교환하여 얻을 수 있는 사전 순으로 가장 작은 문자열을 반환하세요.

두 숫자는 둘 다 홀수이거나 둘 다 짝수일 때 동일한 홀짝성을 가집니다. 예를 들어, 5와 9, 그리고 2와 4는 동일한 홀짝성을 가지지만, 6과 9는 그렇지 않습니다.

#### 예제

**예제 1**:

- 입력: `s = "45320"`
- 출력: `"43520"`
- 설명:
  - `s[1]` == '5'와 `s[2]` == '3'는 둘 다 동일한 홀짝성을 가지며, 이들을 교환하면 사전 순으로 가장 작은 문자열이 됩니다.

**예제 2**:

- 입력: `s = "001"`
- 출력: `"001"`
- 설명:
  - 교환을 할 필요가 없습니다. 이미 사전 순으로 가장 작은 문자열입니다.

#### 제약 조건

- `2 <= s.length <= 100`
- `s`는 숫자로만 구성되어 있습니다.

---

### 문제 풀이 힌트

1. **동일한 홀짝성의 숫자 식별**:
   - 주어진 문자열에서 인접한 동일한 홀짝성을 가진 숫자들을 식별합니다.

2. **가능한 교환 시도**:
   - 인접한 동일한 홀짝성의 숫자들을 최대 한 번 교환하여 사전 순으로 더 작은 문자열을 얻을 수 있는지 확인합니다.

3. **최적의 교환 선택**:
   - 가능한 모든 교환을 시도하여 사전 순으로 가장 작은 문자열을 찾습니다.

이 문제는 간단한 문자열 조작 및 비교를 통해 해결할 수 있으며, 각 교환 후의 문자열을 저장하여 최적의 결과를 반환할 수 있습니다.
*/
