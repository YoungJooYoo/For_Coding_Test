class Solution 
{
public:
    int minSwaps(const vector<int>& nums) 
    {
        const int n = nums.size();
        const int totalOnes = count(nums.begin(), nums.end(), 1);

        if (totalOnes == 0) 
        {
            return 0;
        }
        
        int currentOnes = 0;
        int maxOnes = 0;

        for (int i = 0; i < 2 * n; ++i) 
        {
            if (i >= totalOnes) // 윈도우의 시작 인덱스
            {
                currentOnes -= nums[(i - totalOnes) % n];
            }
            currentOnes += nums[i % n];  // 윈도우에 1 추가
            maxOnes = max(maxOnes, currentOnes); // 윈도우 내 최대 1의 개수를 저장
        }

        return totalOnes - maxOnes;
    }
};

// https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/description/

/*
### 문제 번역

#### **2134. 모든 1을 함께 묶기 위한 최소 스왑 횟수 II**

**난이도**: 중간

---

#### **문제 설명**

배열에서 두 개의 **서로 다른** 위치를 선택하여 값을 서로 바꾸는 작업을 **스왑**이라고 정의합니다.

**원형 배열**은 배열의 첫 번째 요소와 마지막 요소가 **인접**한 것으로 간주되는 배열입니다.

**이진 원형 배열** `nums`가 주어졌을 때, 배열에 존재하는 모든 `1`을 **어느 위치에서든 함께 묶기 위한** 최소 스왑 횟수를 반환하세요.

---

#### **예제**

**예제 1**:
```
입력: nums = [0,1,0,1,1,0,0]
출력: 1
설명: 1을 묶는 방법 중 일부는 다음과 같습니다:
[0,0,1,1,1,0,0] (1번 스왑 사용).
[0,1,1,1,0,0,0] (1번 스왑 사용).
[1,1,0,0,0,0,1] (원형 배열의 속성을 이용하여 2번 스왑 사용).

모든 1을 묶기 위해 최소 스왑 횟수는 1입니다.
```

**예제 2**:
```
입력: nums = [0,1,1,1,0,0,1,1,0]
출력: 2
설명: 1을 묶는 방법 중 일부는 다음과 같습니다:
[1,1,1,0,0,0,0,1,1] (2번 스왑 사용).
[1,1,1,1,1,0,0,0,0] (2번 스왑 사용).

모든 1을 묶기 위해 최소 스왑 횟수는 2입니다.
```

**예제 3**:
```
입력: nums = [1,1,0,0,1]
출력: 0
설명: 모든 1이 이미 원형 배열의 속성으로 묶여 있습니다.
따라서 최소 스왑 횟수는 0입니다.
```

---

#### **제약 사항**
- `1 <= nums.length <= 10⁵`
- `nums[i]`는 `0` 또는 `1`입니다.

---

### 문제를 쉽게 설명

1. **목표**: 원형 배열 `nums`에서 모든 `1`을 연속된 그룹으로 만드는 데 필요한 최소 스왑 횟수를 계산합니다.
   - 스왑은 두 요소의 값을 서로 바꾸는 작업입니다.

2. **원형 배열 특성**: 
   - 배열이 원형이므로 **끝 요소**와 **처음 요소**도 연결된 것으로 간주합니다.

3. **접근 방식**:
   - 먼저 배열에 존재하는 `1`의 총 개수(`totalOnes`)를 계산합니다.
   - 그런 다음, 배열의 길이가 `totalOnes`인 **윈도우**를 이동시키며, 현재 윈도우에 포함된 `1`의 개수를 세고 **최소 이동 횟수**를 구합니다.
   - 원형 배열이므로, 배열의 끝과 시작을 연결하여 **연장된 배열**로 생각합니다.

---

### 문제 풀이 전략

1. **Step 1**: `nums`에서 `1`의 총 개수(`totalOnes`)를 계산합니다.
   - 이 값은 윈도우 크기를 결정합니다.

2. **Step 2**: 배열을 원형으로 간주하기 위해 `nums`를 두 번 반복하여 **연장된 배열**처럼 취급합니다.
   - 배열을 실제로 복사하지 않고, 인덱스를 `% nums.length`로 나누어 계산합니다.

3. **Step 3**: 슬라이딩 윈도우를 사용하여 최소 이동 횟수를 계산합니다.
   - 각 윈도우 내에서 `1`의 개수를 세고, `totalOnes`에서 이를 뺀 값이 현재 윈도우에서 필요한 스왑 횟수입니다.
   - 모든 가능한 윈도우에서 최소 스왑 횟수를 찾습니다.

4. **Step 4**: 결과를 반환합니다.
   - 최소 스왑 횟수를 출력합니다.
*/
