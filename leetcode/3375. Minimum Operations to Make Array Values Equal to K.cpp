class Solution 
{
public:
    int minOperations(const vector<int>& nums, const int k) 
    {
        unordered_set<int> uniqueValues;
        
        for (const auto num : nums)
        {
            if (num < k)
            {
                return FAIL; // k보다 작은 값이 있으면 불가능하므로 -1 반환
            }
            else if (num > k)
            {
                uniqueValues.insert(num); // k보다 큰 고유 값을 추적
            }
        }

        return uniqueValues.size();
    }

private:
    enum { FAIL = -1 };
};

// https://leetcode.com/problems/minimum-operations-to-make-array-values-equal-to-k/

/*
### 국문 번역

**3375. 배열 값을 K로 만들기 위한 최소 연산 횟수**  
난이도: 쉬움  

---

### 문제 설명  
정수 배열 `nums`와 정수 `k`가 주어집니다.  

`h`가 **유효한 정수**라는 것은 배열에서 `h`보다 큰 모든 값이 동일하다는 것을 의미합니다.  
예를 들어, `nums = [10, 8, 10, 8]`일 때 `h = 9`는 유효한 정수입니다. 왜냐하면 `nums[i] > 9`인 모든 값이 `10`으로 동일하기 때문입니다. 하지만 `h = 5`는 유효하지 않습니다.  

다음과 같은 연산을 배열 `nums`에 수행할 수 있습니다:  
1. 현재 `nums` 값들에 대해 유효한 정수 `h`를 선택합니다.  
2. `nums[i] > h`인 모든 인덱스 `i`에 대해 `nums[i] = h`로 설정합니다.  

모든 요소를 `k`로 만들기 위한 최소 연산 횟수를 반환하세요. 만약 모든 요소를 `k`로 만드는 것이 불가능하다면 `-1`을 반환하세요.  

---

### 예제  

**예제 1**  
입력:  
`nums = [5, 2, 5, 4, 5], k = 2`  
출력:  
`2`  
설명:  
- 유효한 정수 `4`와 `2`를 차례로 사용하여 연산을 수행할 수 있습니다.  

**예제 2**  
입력:  
`nums = [2, 1, 2], k = 2`  
출력:  
`-1`  
설명:  
- 모든 값을 `2`로 만드는 것이 불가능합니다.  

**예제 3**  
입력:  
`nums = [9, 7, 5, 3], k = 1`  
출력:  
`4`  
설명:  
- 유효한 정수를 `7`, `5`, `3`, `1`의 순서로 사용하여 연산을 수행할 수 있습니다.  

---

### 제약 조건  
- `1 <= nums.length <= 100`  
- `1 <= nums[i] <= 100`  
- `1 <= k <= 100`  


### 문제 힌트 번역

**힌트 1**  
배열에 **`k`보다 작은 정수**가 포함된 경우를 먼저 처리하세요.  
(만약 `k`보다 작은 값이 있다면, 모든 값을 `k`로 만들 수 없으므로 바로 `-1`을 반환해야 합니다.)

---

**힌트 2**  
가장 큰 정수부터 작업을 시작하세요.  
(큰 값들을 먼저 줄여나가야 최소 작업 횟수로 모든 값을 `k`로 만들 수 있습니다.)

---

**힌트 3**  
- 가장 큰 값을 줄일 때, 두 번째로 큰 값을 기준으로 작업하세요.  
- 두 번째로 큰 값을 줄일 때, 세 번째로 큰 값을 기준으로 작업하세요.  
- 이런 식으로 **큰 값부터 순서대로 줄여나가면 됩니다.**

---

**힌트 4**  
결과는 배열에서 **`k`보다 큰 값들의 고유한 개수**와 같습니다.  
(각 고유 값마다 한 번씩 작업해야 하기 때문입니다.)

*/
