class Solution 
{
public:
    vector<int> elementInNums(const vector<int>& nums, const vector<vector<int>>& queries) 
    {
        const int LENGTH = nums.size();
        const int QURIES_LENGTH = queries.size();
        const int n2 = 2 * LENGTH;
		vector<int> ans(QURIES_LENGTH, -1);

		for (int i = 0; i < QURIES_LENGTH; i++) 
        {
			vector<int> q = queries[i];
			int t = q[0] % n2;
			int cnt = abs(LENGTH - t);
			if (q[1] + 1 <= cnt) 
            {
				if (t > LENGTH) 
                {
					ans[i] = nums[q[1]];
				} 
                else 
                {
					ans[i] = nums[t + q[1]];
				}
			}
		}

		return ans;
    }
};

// https://leetcode.com/problems/elements-in-array-after-removing-and-replacing-elements/description/


/*

물론입니다! 아래는 요청하신 **2113. 요소 제거 및 교체 후 배열의 요소 찾기** 문제의 한국어 번역입니다.

---

### 2113. 요소 제거 및 교체 후 배열의 요소 찾기
**중간 난이도**

**주제**

**기업**

0-인덱스 정수 배열 `nums`가 주어집니다. 처음에 0분에는 배열이 변경되지 않습니다. 매 분마다 `nums`의 가장 왼쪽 요소가 제거되어 더 이상 요소가 남지 않을 때까지 반복됩니다. 그런 다음, 매 분마다 제거된 순서대로 하나의 요소가 `nums`의 끝에 추가되어 원래의 배열이 복원될 때까지 반복됩니다. 이 과정은 무한히 반복됩니다.

예를 들어, 배열 `[0,1,2]`는 다음과 같이 변경됩니다:
```
[0,1,2] → [1,2] → [2] → [] → [0] → [0,1] → [0,1,2] → [1,2] → [2] → [] → [0] → [0,1] → [0,1,2] → ...
```

또한, 크기가 `n`인 2차원 정수 배열 `queries`가 주어집니다. 여기서 `queries[j] = [timej, indexj]`입니다. j번째 쿼리에 대한 답은 다음과 같습니다:

- 0분 이후 `timej` 분이 지난 시점에서 `indexj`가 `nums.length`보다 작은 경우, `nums[indexj]`를 반환합니다.
- `indexj`가 `nums.length` 이상인 경우, `-1`을 반환합니다.

크기가 `n`인 정수 배열 `ans`를 반환하세요. 여기서 `ans[j]`는 j번째 쿼리에 대한 답입니다.

#### 예제 1:

```
입력: nums = [0,1,2], queries = [[0,2],[2,0],[3,2],[5,0]]
출력: [2,2,-1,0]
```

**설명:**

- **0분:** `[0,1,2]` - 모든 요소가 `nums`에 존재합니다.
- **1분:** `[1,2]` - 가장 왼쪽 요소인 `0`이 제거됩니다.
- **2분:** `[2]` - 가장 왼쪽 요소인 `1`이 제거됩니다.
- **3분:** `[]` - 가장 왼쪽 요소인 `2`가 제거됩니다.
- **4분:** `[0]` - `0`이 `nums`의 끝에 추가됩니다.
- **5분:** `[0,1]` - `1`이 `nums`의 끝에 추가됩니다.

각 쿼리에 대한 답은 다음과 같습니다:
- **쿼리 [0,2]:** 0분 시점의 `nums[2]`는 `2`입니다.
- **쿼리 [2,0]:** 2분 시점의 `nums[0]`는 `2`입니다.
- **쿼리 [3,2]:** 3분 시점의 `nums[2]`는 존재하지 않으므로 `-1`입니다.
- **쿼리 [5,0]:** 5분 시점의 `nums[0]`는 `0`입니다.

#### 예제 2:

```
입력: nums = [2], queries = [[0,0],[1,0],[2,0],[3,0]]
출력: [2,-1,2,-1]
```

**설명:**

- **0분:** `[2]` - 모든 요소가 `nums`에 존재합니다.
- **1분:** `[]` - 가장 왼쪽 요소인 `2`가 제거됩니다.
- **2분:** `[2]` - `2`가 `nums`의 끝에 추가됩니다.
- **3분:** `[]` - 가장 왼쪽 요소인 `2`가 제거됩니다.

각 쿼리에 대한 답은 다음과 같습니다:
- **쿼리 [0,0]:** 0분 시점의 `nums[0]`는 `2`입니다.
- **쿼리 [1,0]:** 1분 시점의 `nums[0]`는 존재하지 않으므로 `-1`입니다.
- **쿼리 [2,0]:** 2분 시점의 `nums[0]`는 `2`입니다.
- **쿼리 [3,0]:** 3분 시점의 `nums[0]`는 존재하지 않으므로 `-1`입니다.

#### 제약 사항:

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`
- `n == queries.length`
- `1 <= n <= 10^5`
- `queries[j].length == 2`
- `0 <= timej <= 10^5`
- `0 <= indexj < nums.length`

---

### 📚 **추가 설명 및 힌트**

이 문제는 배열의 요소를 제거하고 다시 추가하는 과정을 시간에 따라 추적해야 하는 문제입니다. 특히, 주어진 시간(`timej`)에 배열의 특정 인덱스(`indexj`)에 어떤 값이 있는지를 효율적으로 찾아야 합니다. 문제의 핵심은 배열의 상태 변화를 효율적으로 모델링하여 쿼리에 빠르게 답변하는 것입니다.

#### 🔍 **힌트:**

1. **순환 패턴 파악하기:**
   - 배열의 상태는 `k`분 동안 요소가 제거되고 다시 추가되는 순환 패턴을 가집니다.
   - 이 순환 패턴을 이해하면, 특정 시점의 배열 상태를 계산하는 데 도움이 됩니다.

2. **완전한 순환 주기 계산:**
   - 배열의 초기 길이를 `n`이라 할 때, 요소가 모두 제거되고 다시 추가되는 데 걸리는 시간을 계산합니다.
   - 한 주기의 길이는 `2n`분입니다 (n분 동안 요소 제거, n분 동안 요소 추가).

3. **주기를 이용한 시간 단순화:**
   - 주기의 길이를 이용하여 `timej`를 주기로 나눈 나머지를 계산합니다.
   - 이를 통해 큰 시간(`timej`) 값도 효율적으로 처리할 수 있습니다.

4. **각 시점에서 배열의 상태 추적:**
   - 주어진 시간에 따라 배열이 요소 제거 단계인지, 요소 추가 단계인지를 판단합니다.
   - 이를 기반으로 배열의 현재 상태를 결정할 수 있습니다.

5. **빠른 접근을 위한 데이터 구조 활용:**
   - 쿼리가 많으므로, 각 쿼리에 대해 배열 상태를 일일이 계산하는 것은 비효율적입니다.
   - 대신, 배열의 요소 제거 및 추가 과정의 패턴을 미리 계산하거나, 특정 시점의 배열 상태를 빠르게 도출할 수 있는 방법을 고안해야 합니다.

6. **효율적인 쿼리 처리:**
   - 쿼리가 많을 때, 각 쿼리를 독립적으로 처리하기보다는, 배열 상태의 패턴을 활용하여 여러 쿼리를 동시에 처리하는 방법을 고려해보세요.

#### 🛠 **문제 접근 방법 요약:**

1. **순환 주기 계산:**
   - 한 주기의 길이를 `2n`분으로 설정합니다.

2. **각 쿼리에 대해:**
   - `timej`를 `2n`으로 나눈 나머지를 구합니다.
   - 나머지에 따라 배열의 상태가 요소 제거 단계인지, 요소 추가 단계인지를 판단합니다.
   - 현재 배열 상태에서 `indexj` 위치의 값을 결정합니다.
   - 만약 `indexj`가 현재 배열의 길이보다 크거나 같다면, `-1`을 반환합니다.

3. **효율성 고려:**
   - 모든 쿼리를 반복문을 통해 일일이 처리하면 시간 초과가 발생할 수 있습니다.
   - 배열의 상태 변화를 패턴화하여, 특정 시점의 배열 상태를 빠르게 도출하는 방법을 고안해야 합니다.

---

### 🧮 **예시 흐름 설명:**

#### 예제 1:
- **입력:** `nums = [0,1,2]`, `queries = [[0,2],[2,0],[3,2],[5,0]]`
- **출력:** `[2,2,-1,0]`

**상태 변화:**
1. **0분:** `[0,1,2]`
2. **1분:** `[1,2]`
3. **2분:** `[2]`
4. **3분:** `[]`
5. **4분:** `[0]`
6. **5분:** `[0,1]`

**쿼리 답변:**
- `timej = 0`, `indexj = 2` → `nums[2] = 2`
- `timej = 2`, `indexj = 0` → `nums[0] = 2`
- `timej = 3`, `indexj = 2` → `nums[2]` 없음 → `-1`
- `timej = 5`, `indexj = 0` → `nums[0] = 0`

#### 예제 2:
- **입력:** `nums = [2]`, `queries = [[0,0],[1,0],[2,0],[3,0]]`
- **출력:** `[2,-1,2,-1]`

**상태 변화:**
1. **0분:** `[2]`
2. **1분:** `[]`
3. **2분:** `[2]`
4. **3분:** `[]`

**쿼리 답변:**
- `timej = 0`, `indexj = 0` → `nums[0] = 2`
- `timej = 1`, `indexj = 0` → `nums[0]` 없음 → `-1`
- `timej = 2`, `indexj = 0` → `nums[0] = 2`
- `timej = 3`, `indexj = 0` → `nums[0]` 없음 → `-1`

---

### 📌 **결론**

이 문제는 배열의 상태 변화를 시간에 따라 추적하고, 주어진 시점에서 특정 인덱스의 값을 효율적으로 찾아내는 문제입니다. 주기를 활용한 시간 단순화와 패턴 인식을 통해, 큰 입력과 많은 쿼리에서도 효율적으로 문제를 해결할 수 있습니다.

추가적인 질문이나 도움이 필요하시면 언제든지 말씀해주세요!
*/
