class Solution 
{
public:
    vector<int> maximumLengthOfRanges(const vector<int>& nums) 
    {
        const int n = nums.size();
        vector<int> left(n, -1);  // 왼쪽 경계
        vector<int> right(n, n);  // 오른쪽 경계
        stack<int> s;

        // 왼쪽 경계 찾기 (왼쪽에서 오른쪽으로)
        for (int i = 0; i < n; ++i)
        {
            while (!s.empty() && nums[s.top()] < nums[i])
            {
                s.pop();
            }
            if (!s.empty())
            {
                left[i] = s.top();
            }
            s.push(i);
        }

        // 스택 초기화
        while (!s.empty())
        {
            s.pop();
        } 

        // 오른쪽 경계 찾기 (오른쪽에서 왼쪽으로)
        for (int i = n - 1; i >= 0; --i)
        {
            while(!s.empty() && nums[s.top()] < nums[i]) 
            {
                s.pop();
            }
            if(!s.empty())
            {
                right[i] = s.top();
            }
            s.push(i);
        }

        // ans 배열 계산, max sub array length
        vector<int> ans(n, 0);
        for (int i = 0; i < n; ++i)
        {
            ans[i] = right[i] - left[i] - 1;
        }

        return ans; 
    }
};

// https://leetcode.com/problems/maximal-range-that-each-element-is-maximum-in-it/

/*

2832. 각 요소가 최대인 최대 범위

중간 난이도

주제

	•	배열
	•	스택
	•	스택을 이용한 알고리즘

기업

힌트
주어진 배열 nums에서 각 요소가 해당 서브배열의 최대값이 되는 가장 긴 서브배열의 길이를 찾아야 합니다. 스택을 활용하여 효율적으로 각 요소의 왼쪽과 오른쪽에서 자신보다 큰 요소를 찾는 방법을 고려해보세요.

📄 문제 설명

고유한 정수로 이루어진 0-인덱스 배열 nums가 주어집니다.

같은 길이의 0-인덱스 배열 ans를 다음과 같이 정의합니다:

	•	ans[i]는 서브배열 nums[l..r]의 최대 길이로, 이 서브배열에서 최대 요소가 nums[i]와 같아야 합니다.

배열에서 서브배열이란, 배열의 연속된 부분을 의미합니다.

배열 nums를 만족하는 배열 ans를 반환하세요.

💡 예제 1:

입력: nums = [1,5,4,3,6]
출력: [1,4,2,1,5]

설명:

	•	nums[0] = 1일 때, 1이 최대인 가장 긴 서브배열은 nums[0..0]로 길이는 1입니다. 따라서 ans[0] = 1.
	•	nums[1] = 5일 때, 5가 최대인 가장 긴 서브배열은 nums[0..3]로 길이는 4입니다. 따라서 ans[1] = 4.
	•	nums[2] = 4일 때, 4가 최대인 가장 긴 서브배열은 nums[2..3]로 길이는 2입니다. 따라서 ans[2] = 2.
	•	nums[3] = 3일 때, 3이 최대인 가장 긴 서브배열은 nums[3..3]로 길이는 1입니다. 따라서 ans[3] = 1.
	•	nums[4] = 6일 때, 6이 최대인 가장 긴 서브배열은 nums[0..4]로 길이는 5입니다. 따라서 ans[4] = 5.

💡 예제 2:

입력: nums = [1,2,3,4,5]
출력: [1,2,3,4,5]

설명:
각 nums[i]에 대해, 해당 요소가 최대인 가장 긴 서브배열은 항상 nums[0..i]이므로, ans[i] = i + 1입니다.

📌 제약 사항:

	•	1 <= nums.length <= 10^5
	•	1 <= nums[i] <= 10^5
	•	nums의 모든 요소는 서로 다릅니다. (즉, nums는 1부터 nums.length까지의 정수의 순열입니다.)

🧠 힌트

이 문제는 각 요소가 자신의 최대 범위에서 얼마나 멀리 확장될 수 있는지를 찾는 문제입니다. 이를 효율적으로 해결하기 위해 스택을 사용하여 각 요소의 왼쪽과 오른쪽에서 자신보다 큰 요소의 위치를 찾는 방법을 고려해보세요. 이렇게 하면 각 요소에 대해 O(1) 시간에 최대 범위를 계산할 수 있습니다.

📘 해결 방법 개요

	1.	왼쪽 경계 찾기:
	•	각 요소의 왼쪽에서 자신보다 큰 요소의 위치를 찾습니다.
	2.	오른쪽 경계 찾기:
	•	각 요소의 오른쪽에서 자신보다 큰 요소의 위치를 찾습니다.
	3.	최대 범위 계산:
	•	왼쪽 경계와 오른쪽 경계를 이용하여 각 요소가 최대인 서브배열의 길이를 계산합니다.
	4.	결과 배열 구성:
	•	계산된 최대 범위 길이를 ans 배열에 저장합니다.

스택을 이용하여 왼쪽과 오른쪽 경계를 효율적으로 찾을 수 있으며, 전체 알고리즘의 시간 복잡도는 O(n)입니다.
*/
