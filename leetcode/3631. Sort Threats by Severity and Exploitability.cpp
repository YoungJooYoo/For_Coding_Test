class Solution 
{
public:
    vector<vector<int>> sortThreats(vector<vector<int>>& threats) const
    {
        assert(MIN_THREATS_LENGTH <= threats.size() && threats.size() <= MAX_THREATS_LENGTH);

        auto cmp = [](const pair<long long, vector<int>>& a, const pair<long long, vector<int>>& b) 
        {
            if (a.first != b.first) return a.first < b.first; 
            return a.second[0] > b.second[0]; 
        };

        priority_queue<pair<long long, vector<int>>, vector<pair<long long, vector<int>>>, decltype(cmp)> pq(cmp);
        vector<vector<int>> result;

        for (const auto& threat : threats)
        {
            const int ID = threat[0];
            const int sev = threat[1];
            const int exp = threat[2];
            const long long score = 2 * static_cast<long long>(sev) + exp;
            pq.push({score, {ID, sev, exp}});
    
            assert(threat.size() == MAX_THREAT_LENGTH);
            assert(MIN_ID <= ID && ID <= MAX_ID);
            assert(MIN_ELEM <= sev && sev <= MAX_ELEM);
            assert(MIN_ELEM <= exp && exp <= MAX_ELEM);
        }

        while (!pq.empty())
        {
            assert(pq.top().second.size() == MAX_THREAT_LENGTH);
            result.push_back(pq.top().second);
            pq.pop();
        }

        assert(result.size() == threats.size());
        return result;
    }

private:
    enum
    {
        MIN_THREATS_LENGTH = 1,
        MAX_THREATS_LENGTH = 100000,
        MAX_THREAT_LENGTH = 3,
        MIN_ID = 1,
        MAX_ID = 1000000,
        MIN_ELEM = 1,
        MAX_ELEM = 1000000000,
    };
};

// https://leetcode.com/problems/sort-threats-by-severity-and-exploitability/description/

/*


### 3631. 심각도와 악용 가능성에 따른 위협 정렬

2차원 정수 배열 `threats`가 주어집니다. 각 `threats[i]`는 `[IDi, sevi, expi]`의 형식을 가집니다.

*   `IDi`: 위협의 고유 식별자입니다.
*   `sevi`: 위협의 심각도를 나타냅니다.
*   `expi`: 위협의 악용 가능성을 나타냅니다.

i번째 위협의 **점수(score)**는 다음과 같이 정의됩니다: `점수 = 2 × sevi + expi`

당신의 임무는 `threats` 배열을 점수의 **내림차순**으로 정렬하여 반환하는 것입니다.

만약 여러 위협의 점수가 같다면, ID를 기준으로 **오름차순**으로 정렬하세요.

**예시 1:**

**입력:** `threats = [[101,2,3],[102,3,2],[103,3,3]]`
**출력:** `[[103,3,3],[102,3,2],[101,2,3]]`
**설명:**

| 위협        | ID  | sev | exp | 점수 = 2 × sev + exp |
| ----------- | --- | --- | --- | -------------------- |
| threats[0]  | 101 | 2   | 3   | 2 × 2 + 3 = 7        |
| threats[1]  | 102 | 3   | 2   | 2 × 3 + 2 = 8        |
| threats[2]  | 103 | 3   | 3   | 2 × 3 + 3 = 9        |

정렬된 순서: `[[103, 3, 3], [102, 3, 2], [101, 2, 3]]`

**예시 2:**

**입력:** `threats = [[101,4,1],[103,1,5],[102,1,5]]`
**출력:** `[[101,4,1],[102,1,5],[103,1,5]]`
**설명:**

| 위협        | ID  | sev | exp | 점수 = 2 × sev + exp |
| ----------- | --- | --- | --- | -------------------- |
| threats[0]  | 101 | 4   | 1   | 2 × 4 + 1 = 9        |
| threats[1]  | 103 | 1   | 5   | 2 × 1 + 5 = 7        |
| threats[2]  | 102 | 1   | 5   | 2 × 1 + 5 = 7        |

`threats[1]`과 `threats[2]`는 점수가 같으므로, ID를 기준으로 오름차순 정렬합니다.
정렬된 순서: `[[101, 4, 1], [102, 1, 5], [103, 1, 5]]`

**제약 조건:**

*   `1 <= threats.length <= 10^5`
*   `threats[i] == [IDi, sevi, expi]`
*   `1 <= IDi <= 10^6`
*   `1 <= sevi <= 10^9`
*   `1 <= expi <= 10^9`
*   모든 `IDi`는 고유합니다.
*/
